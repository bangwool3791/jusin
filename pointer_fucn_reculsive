1. 포인터형변환 : 타입 캐스팅 시 메모리 공간은 변하지 않으나, 변수를 불러오기전 임시 저장 공간이 있다는 뉘앙스 이고 이 공간이 int->float형으로 변함

2. pointer 연산자 : char형 포인터는 ++연산시 주소값 +1, int형 포인터는 주소값 +4가된다. 

3. pointer의 장점 : 할당된 메모리 공간을 접근 할 수 있다는 것
             단점 : 할당되지 않은 메모리 공간을 접근 할 수 있다는 것
			 
			 
RAM : 휘발성 메모리, PC 종료 시 메모리 초기화

const 상수 초기화 안 할 때, 쓰레기 값으로 초기화 가능, 이 값을 rvalue로 사용해 lvalue에 넣을 때 문제 발생.


int iA = 10;
int iB = 30;

const int* p = &iA;
p가 가리키는 값은 변경 불가능.
p = &iB;
p의 주소 값은 변경 가능.

int* const p = &iA;
p가 가리키는 값은 변경 가능.
*p = 30;
p = &iB;
p의 주소 값은 변경 불가능.

const int* const p = &iA;

포인터의 주소값 변경도 포인터가 가리키는 공간의 값 변경도 불가.
Class의 This가 이럼. This가 가리키는 멤버변수는 변경????

포인터의 포인터 

3개의 연속 된 포인터가 있을 때, 이 포인터의 주소를 저장함으로 써 메모리 공간을 효율적으로 관리한다.
즉 2중 포인터는 포인터(메모리 주소)를 관리하기 위한 포인터이다.

int iA = 10, iB, iC;
int* p = &iA, p1 = &iB, p2 = &iC;

int** pp = p;

++pp = p1;
++pp = p2; 

이중포인터 사용 : 플레이어의 HP가 전투 후에는 100->90으로 깍인다. 
A라는 공간에 플레이어가 있으면 B라는 전투처에서 플레이어라는 주소의 값을 받아온다. 그리고 A라는 공간 안에있는 C라는 공간에 B의 플레이어를 넘겨주는데 이중포인터를 사용한다.

*&p = p
&*p = x (값 자체는 리터럴 상수 이므로 주소 추출이 안된다.)

const Pointer* const this는 자기가 소유하는 것들에 대한 변수, 소유권을 나타내기 위한 포인터. 멤버 변수는 변경 가능. 따라서 this의 주소가, this자체의 값 변경이 안된다.

과제 : Swap함수 포인터로 구현.

함수의 사용 이유 : 코드의 재 사용성을 위해 사용.
메인 함수 : 진입점 함수
